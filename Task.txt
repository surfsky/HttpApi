-------------------------------------------------
任务
-------------------------------------------------
hebin decoder



考虑
    实现 MaxDepth 逻辑，限制json输出层次。。。。。
    尝试合并HttpApiAttribute 和 API 类，基本重叠。
        合并会很麻烦，很多冗余字段
        可考虑用继承的方式实现
            HttpApiAttribute 继承自 Attribute
            API 可继承自 HttpApiAttribute
    实现异步长连接接口，可用于发送消息（直接用SignalR？）

增加
    完善自动封装能力（WrapCondition） ，仅支持基础数据类型
        0-text;1-text;2-text;  
        true:text;false:text; 
        Ok:text;Finished:text;
    完善导出 Xml 能力
        可控制：
            以属性方式还是以成员方式展示，以精简xml输出
                基础类型数据（string、number、datetime、bool、enum），都可以简单.ToText() 输出数据
                复杂对象类型，以成员方式展示（类似XAML）
                列表类型、字典类型。
            支持 XmlAttribute 标签
        维护一个输出对象表，避免无限循环
        考虑构建一个 XmlDocument 对象，最后再根据格式参数生成 xml 文本





-------------------------------------------------
已完成
-------------------------------------------------
2019-11-26
    /PostFile
     /HttpApiAttribute.PostFile 可以删除掉。构造测试表单时都采用multipart方式即可？算了，保留，表示需要添加文件
    /增加访问间隔控制
        /AuthInterval/VisitInterval，限制访问间隔
        /需维护一个字典或内存表：ClientIP, Api, LastVisitDt，会自动删除老数据
        /需要限制的接口如：登录、获取用户信息
    /增加文件上传处理能力, 参数如：string Upload(byte[] file, string name)
    /编纂英文版的readme

2019-11
    /增加接口过期时间，可用于逐步更替老旧接口。算了，增加Delete状态，不提供服务。
    /ApiStatus fix
    /fix bug
        http://doc.oa.wz.zj.cn:88/HttpApi/Knowledge/GetArticles
        public static APIResult GetArticles(string keywords, string dirIds="", ArticleSortType? sort = ArticleSortType.Date, int pageIndex = 0, int pageSize = 50)
        如果 sort参数不填写的话，报错: "Object of type 'System.Int32' cannot be converted to type 'System.Nullable`1[App.DAL.ArticleSortType]'."
        策略：枚举可空类型的默认值预先处理一下，转化为枚举类型




2019-10
    移除 App.Core 依赖，但还是要用到 UIAttribute（用反射避免了使用）

2019-05-10
    /修正 HttpApi 方法未找到的提示错误

2019-04-30
    /增加测试页面：/HttpApi/Common/Echo$  /HttpApi/Common/Echo!

2019-04-28
    /增加 HttpApiAttribute.Log 属性，可在OnVisit事件中判断并做日志
    /增加 HttpApiConfig.OnVisit 事件，可查看访问时的详细情况
    
2018-11-30
    /修正bug：可空类型，若输入为空会出错，如：
    /https://bearmanager.cn/HttpApi/Mall/GetProducts?type=

2018-11-26
    /方法名支持下划线

2018-11-21
    /增加事件：HttpApiConfig.OnException

2018-10-31
    /App.Components 拆分出 App.Core 项目，稳定基本不变更
    /优化默认参数逻辑，请求时可留空也可以不填写
        http://localhost:5625/HttpApi/Base/GetArticles?type=normal&pageSize=&pageIndex=
        http://localhost:5625/HttpApi/Base/GetArticles?type=normal
    /优化httpapi，支持枚举类型参数用字符串表示
        http://localhost:5625/HttpApi/Base/GetArticles?type=normal&pageSize=5&pageIndex=1
        http://localhost:5625/HttpApi/Base/GetArticles?type=1&pageSize=5&pageIndex=1

2018-10-30
    /HttpApiAttribute 增加 Example 参数
    /测试可空类型 int? n 参数
    /Bug：Xml 报错时的输出格式应该也是 xml，现在是json（算了）

2018-10-23
    /增加日志能力（放弃，可丢到鉴权接口，由用户自己去完成）
    /完善Xml导出
        /考虑使用通用的attribute来标注字段格式和输出
            /通用标注
                System.ComponentModel.DataAnnotations
                Required
                StringLength
                DataType
                [AcceptVerbs("Get", "Post")]
                [RegularExpression(pattern:"d+",ErrorMessage ="不符合正则规则")]
            /或只使用JsonXXXXX, 其它的以Json为准（采用）
        /null值处理
        /字符串类型（含CData处理: < &）
        /枚举处理
        /值类型
        /时间类型
        /可空类型
        /匿名类型
        /字典类型
    /输出 xml 类型出错
        /http://localhost:4350/HttpApi/DemoClass/GetPersonData?_type=xml
        /对于未知类型，用 System.Xml.Serialization.XmlSerializer 会报错，必须预先 [XmlInclude(typeof(MyType)])]
        /考虑用三方 xml 序列化类(Ok)，或者用 Json.net 好像也可以(NO)


2018-10-22
    /简化Api路径(增加 HttpConfig.ApiTypePrefix 属性)，路径名如：/HttpApi/Common/GetThumbnail
    /修正Js导出路径问题
    /增加json配置：formatSmallCamel 小驼峰命名法
    /实现导出 xml
        /null值处理
        /字符串类型（CData处理）
        /枚举处理
        /值类型
        /时间类型
        /可空类型
        /匿名类型

2018-10-19
    /移除 AuthIPs 配置项，用事件替代
    /移除 HttpApiAuth，使用 App.Components.AuthHelper
    /增加自定义鉴权事件
    /增加鉴权标签：AuthIP, AuthSecurityCode
    /优化调用目录
        /如 HttpApi/A.B.C/Method，用 Module 或者 RouteTable 实现
        /改为HttpModule

2018-10-18
    /引用App.Components
    /生成Api展示页面
    /修改API清单页面
    /增加 ParameterAttribute：Name，Description，Default
    /AuthHelper 更名为 HttpApiAuth
    /HttpApi 可空类型的枚举类型展示
    /优化参数类型字符串
        基础数值类型：String, Int, Decimal
        枚举类型
        可空类型

2018-10-17
    /增加DataResult(object) 构造函数
    /修改分页组建参数名称：Total, PageSize, PageCount, PageIndex, 

2018-10-11
    /增加 ApiStatus, Verbs
    /修改 ApiHtml 的显示
    /增加配置：jsonEnumFormatting="Text" jsonIndented="Indented" jsonDateTimeFormat="yyyy-MM-dd"

2018-10-10
    /DataResult 构造方法第一个参数可为bool值
    /接口排序
    /a=xxx -> a=x
    /升级Newtonsoft.Json -> 6.0

2018-02-23
    /更改内嵌资源名称（去除下划线）

2017-12-14
    /重构Tool类，拆分为多个类
    /重构HttpApiHandler类，更清晰
    /增加全局配置：SuccessInfo 成功时返回的信息。
    /增加全局配置：AuthIPs，仅指定ip内的客户端才可以访问。
    /增加全局配置：EnumResponse，指定枚举类型的返回方式
    /增加方法特性：Verbs=“Get,Post"，可限制访问的动词
    /将SuccessInfo-》WrapInfo，移到方法特性里面去，无需全局配置

2017-12-12
    /Nuget发布: install-package App.HttpApi
    /增加全局配置
        public HttpApiConfig
        {
           public string SuccessInfo {get; set;}
           public string FailInfo {get; set;}
           public string AuthIPs {get; set;}
           public string LoggerName {get; set;}
        }


2017-12-01
    /更改名称: HttpApi, WebApi, Api
    /增加日志能力：结合nlog。算了，页面访问一般网站都有全局的model来监控


2017-11-24
    /IQuaryable<T> 类型数据的自动封装
        取消，接口中常直接返回匿名对象
        还有page、pagesSize等逻辑
        结论：还是由用户直接在接口中处理吧

2017-11-23
    /非string、image类型，默认类型输出为 json（已有该逻辑，查看方法 HttpApiHelper.ParseDataType）
    /增加默认参数Description
    /去除appsetting-wrapper全局设置（不实用）
    /删除HttpApiAttribute.IClonable接口
    /gzip支持（算了，由iis直接提供吧）
    /去除Format属性
    /优化缓存
        /CacheDuration -> CacheSeconds
        /增加缓存位置属性 CacheLocation
    /修改 Wrap 逻辑
        /将Wrapper改为bool属性
        /注：现在的Wrap只影响到 Json 类型的输出
        /还是另外定一个 ResponseType=JsonWrap。放弃。
        /使用单独的 Wrap 属性。并扩展到xml、imagebase64、普通text的输出
    /增加Wrapper特性
        - None: 不封装，直接输出到客户端
        - DataResult: 用DataResult类封装
        该方案用于服务器端和客户端的适配
        - 服务器端可能只需要直接的数据；
        - 而对于接口而言，可能需要用统一的结构来封装（如DataResult）
        或者使用全局appsetting设定
        <item key=webcall-wrapper value="DataResult"/>

/增加historyattribute/DescriptionAttribute
/修正getimage错误（去掉response.end)
/新增api参数，显示所有接口
/部署到服务器上试试，看HttpContext.Current.User;到底是什么
//删除                 case ResponseDataType.HTML: return new HtmlEncoder(context);
//枚举会转化为数字输出。。。应该转化为字符串，用newtonsoft.json怎么玩？
//简化DataRow的输出结果
/将AuthHelper集成到HttpApi组件（2015-04-28）
/修改JsonWrapper -> Wrapper（2015-04-28）
/修改HttpApi，增加授权逻辑（2014-05-12）
    - 集成DataResult类
    - 将js文件丢到Js目录下
    - 拆分Tools类
    - 令其支持以下特性(attribute)：
        - AllowAnonymous：是否允许匿名访问（默认为true）
        - AllowUsers ：允许访问的用户
        - AllowRoles ：允许访问的角色
    - 若无授权访问会返回401错误或DataResult对象 （可在Web.confit中配置HttpApi-ErrorResponse=HttpError/DataResult）
    - 使用方法
        - 确保ASP.NET 页面实现 HttpContext.Current.User 接口（用于获取当前用户的信息）
        - 请打开所有HttpApi的访问权限，无需登录
        - 在需要认证的方法上加上以上标签
    - 详细内容可参考 TestAuth.aspx 示例页面
/修改缓存逻辑，根据有效输入参数来缓存，无效参数不予理会(2013-04-26)
/null值处理
/json数据转换为类实体
    void Update(Person person)
    json {Name:xxx, First:xxx, Last:xxx, Sex:'male'}
    请参考asp.net WebApi
    http://aspnetwebstack.codeplex.com/
    return JsonConvert.DeserializeObject<T>(json, _jsonSettings); 
    JsonSerializerSettings _jsonSettings = new JsonSerializerSettings(); 
    _jsonSettings.MissingMemberHandling = Newtonsoft.Json.MissingMemberHandling.Ignore; 
    _jsonSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore; 
    _jsonSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore; 
    IsoDateTimeConverter datetimeConverter = new IsoDateTimeConverter(); 
    datetimeConverter.DateTimeFormat = "yyyy-MM-dd HH:mm:ss"; 
    _jsonSettings.Converters.Add(datetimeConverter); 
/若实现了IDisposal接口，自动调用释放资源
/增加访问权限控制
    [AccessUsers="xxx,xxx", AccessRoles="xxx,xxx"]
/数据返回类型可用Accepted来控制，而非_type
/客户端可指定js类名
/尝试根据方法的输出类别来推断输出格式
/增加图像输出（png、gif、base64）
/输出服务地址
/废除extjs和jquery两种版本的输出，没啥意义，保留原始js就好了
/恢复HttpApiHttpHandler
/恢复HttpApiHttpPage（客户端屏蔽了contentType:json,不建议使用）
/支持输出extjs脚本
/支持输出普通js脚本
/WebMethod->HttpApi
/考虑废除 WebMethodHandler 和 WebMethodModule
    (1)写class，并用 [WebMethod] 标注
    (2)注册axd:
    (3)ashx调用：
        注册：<script src="CallType_xxx.xxx.axd/js"></script>
        调用：WebMethod_xxx.xxx.axd/HelloWorld?info=me
    (4)aspx调用：
        注册：<script src="CallPage_xxx.xxx.axd/js"></script>
        调用：WebMethod_xxx.xxx.axd/HelloWorld?info=me


-------------------------------------------------------------
参考代码
-------------------------------------------------------------
    // 获取ajax对象
    GetAjaxObject : function(){
        if (window.ActiveXObject) {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } else if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }
    },
            if (decoder == null) decoder = new SimpleUrlDecoder(context);
        <li><a href="HttpApi.App.DemoClass.axd/jq">查看App_Code类映射到客户端的js文件（依赖jquery)</a></li>
        <li><a href="HttpApi.App.DemoClass.axd/ext">查看App_Code类映射到客户端的js文件（依赖ExtJs)</a></li>
        <li><a href="CallClass.aspx">调用App_Code类方法（依赖jquery）</a></li>
        <li><a href="CallExt.aspx">调用App_Code类方法（依赖ExtJs）</a></li>

        static ResponseDataType ParseDataType(object o)
        {
            if (o is string)                return ResponseDataType.Text;
            if (o is StringBuilder)         return ResponseDataType.Text;
            if (o is DateTime)              return ResponseDataType.Text;
            if (o is System.Data.DataTable) return ResponseDataType.JSON;
            if (o is System.Drawing.Image)  return ResponseDataType.Image;

            return ResponseDataType.JSON;
        }


        private void Call(string typeName, HttpContext context)
        {
            // 先尝试从缓存中获取处理器
            string cacheName = "HttpApi-" + typeName;
            object o = Cache[cacheName];
            if (o != null)
            {
                App.HttpApi.HttpApiHelper.ProcessRequest(context, o);
                return;
            }

            // 找不到着遍历程序集去找这个类
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly assembly in assemblies)
            {
                // 过滤掉系统自带的程序集
                string name = assembly.FullName;
                if (name.StartsWith("System") || name.StartsWith("Microsoft") || name.StartsWith("mscorlib"))
                    continue;

                // 尝试创建对象，且处理Web方法调用请求
                object handler = assembly.CreateInstance(typeName, true);
                if (handler != null)
                {
                    App.HttpApi.HttpApiHelper.ProcessRequest(context, handler);
                    Cache.Add(cacheName, handler, null,
                        Cache.NoAbsoluteExpiration, new TimeSpan(0, _cacheMinutes, 0),
                        CacheItemPriority.Default,
                        null);
                    break;
                }
            }
        }
            /*
            if (result == null)
                HttpContext.Current.Response.Write("null");
            else
                encoder.Write(result);
            */


        /// <summary>
        /// 列出接口清单
        /// </summary>
        static StringBuilder GetInterfaceText(Type type)
        {
            // 读取对应的模板
            string script = "";
            Uri uri = HttpContext.Current.Request.Url;
            string filePath = HttpContext.Current.Request.FilePath;
            string url = string.Format("{0}://{1}{2}", uri.Scheme, uri.Authority, filePath);

            // 依次生成函数调用脚本
            StringBuilder scriptBuilder = new StringBuilder(script);
            MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
            foreach (MethodInfo method in methods)
            {
                HttpApiAttribute attr = Tool.GetWebMethodAttribute(method);
                if (attr != null)
                {
                    //scriptBuilder.AppendLine("<h2>" + attr.Description + "</h2>");
                    scriptBuilder.AppendLine(attr.Description);
                    scriptBuilder.AppendLine("    地址  : " + GetMethodUrl(url, method));
                    scriptBuilder.AppendLine("    缓存  : " + attr.CacheDuration.ToString() + " 秒");
                    scriptBuilder.AppendLine("    类型  : " + ParseDataType(attr.Type, method.ReturnType).ToString());
                    scriptBuilder.AppendLine("    备注  : " + attr.Remark);
                    scriptBuilder.AppendLine("    限登录: " + attr.AuthLogin);
                    scriptBuilder.AppendLine("    限用户: " + attr.AuthUsers);
                    scriptBuilder.AppendLine("    限角色: " + attr.AuthRoles);
                    scriptBuilder.AppendLine("");
                }
            }
            return scriptBuilder;
        }
            public Api(string name, string description, string type, int cacheDuration, bool authLogin, string authUsers, string authRoles, string remark, string url)
            {
                this.Name = name;
                this.Description = description;
                this.Type = type;
                this.CacheDuration = cacheDuration;
                this.AuthLogin = authLogin;
                this.AuthUsers = authUsers;
                this.AuthRoles = authRoles;
                this.Remark = remark;
                this.Url = url;
            }


                    /// <summary>
        /// 列出接口清单（考虑用GetInterfaces方法重构）
        /// </summary>
        static StringBuilder GetInterfaceHtml(Type type)
        {
            // 读取对应的模板
            string script = "";
            Uri uri = HttpContext.Current.Request.Url;
            string filePath = HttpContext.Current.Request.FilePath;
            string url = string.Format("{0}://{1}{2}", uri.Scheme, uri.Authority, filePath);

            // 依次生成函数调用脚本
            StringBuilder sb = new StringBuilder(script);
            MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
            //sb.AppendLine("<b>" + url + "</b>");
            sb.AppendLine("<table border=1 style='border-collapse: collapse' width='100%' cellpadding='2' cellspacing='0'>");
            sb.AppendLine("<tr><td width='200'>接口名</td><td width='300'>说明</td><td width='70'>类型</td><td width='70'>缓存</td><td width='70'>限登录</td><td width='70'>限用户</td><td width='70'>限角色</td><td>备注</td><td>完整地址</td></tr>");

            foreach (MethodInfo method in methods)
            {
                HttpApiAttribute attr = Tool.GetWebMethodAttribute(method);
                if (attr != null)
                {
                    sb.AppendFormat("<tr><td>{0}&nbsp;</td><td>{1}&nbsp;</td><td>{2}&nbsp;</td><td>{3}&nbsp;</td><td>{4}&nbsp;</td><td>{5}&nbsp;</td><td>{6}&nbsp;</td><td>{7}&nbsp;</td><td>{8}&nbsp;</td></tr>"
                        , method.Name
                        , attr.Description
                        , ParseDataType(attr.Type, method.ReturnType)
                        , attr.CacheDuration.ToString() + " 秒"
                        , attr.AuthLogin
                        , attr.AuthUsers
                        , attr.AuthRoles
                        , attr.Remark
                        , GetMethodUrl(url, method)
                        );
                }
            }
            return sb;
        }


                /// <summary>
        /// 生成客户端调用服务器端方法的脚本（考虑用GetInterfaces方法重构）
        /// </summary>
        static StringBuilder GetJs(Type type, string nameSpace, string className, int cacheDuration, string scriptType="js")
        {
            // 读取对应的模板
            string script = GetTemplateScript(scriptType);
            Uri uri = HttpContext.Current.Request.Url;
            string filePath = HttpContext.Current.Request.FilePath;

            // 并进行字符串替换：描述、时间、地址、类名
            string url = string.Format("{0}://{1}{2}", uri.Scheme, uri.Authority, filePath);
            script = script.Replace("%DATE%", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
            script = script.Replace("%DURATION%", cacheDuration.ToString());
            script = script.Replace("%URL%", url);
            script = script.Replace("%NS-BUILD%", GetNamespaceScript(nameSpace));
            script = script.Replace("%NS%", nameSpace);
            script = script.Replace("%CLS%", className);

            // 依次生成函数调用脚本
            StringBuilder scriptBuilder = new StringBuilder(script);
            MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
            foreach (MethodInfo method in methods)
            {
                HttpApiAttribute attr = Tool.GetWebMethodAttribute(method);
                if (attr != null)
                {
                    scriptBuilder.AppendLine("//-----------------------------------------------------------------");
                    scriptBuilder.AppendLine("// 说明  : " + attr.Description);
                    scriptBuilder.AppendLine("// 地址  : " + GetMethodUrl(url, method));
                    scriptBuilder.AppendLine("// 缓存  : " + attr.CacheDuration.ToString() + " 秒");
                    scriptBuilder.AppendLine("// 类型  : " + ParseDataType(attr.Type, method.ReturnType).ToString());
                    scriptBuilder.AppendLine("// 备注  : " + attr.Remark);
                    scriptBuilder.AppendLine("// 限登录: " + attr.AuthLogin);
                    scriptBuilder.AppendLine("// 限用户: " + attr.AuthUsers);
                    scriptBuilder.AppendLine("// 限角色: " + attr.AuthRoles);
                    scriptBuilder.AppendLine("//-----------------------------------------------------------------");

                    string func = GetFunctionScript(nameSpace, className, method, attr.Type);
                    scriptBuilder.AppendLine(func);
                }
            }

            // 插入json2.js并输出
            scriptBuilder.Insert(0, GetJsonScript());
            return scriptBuilder;
        }

        
        //---------------------------------------------------
        // 内部属性
        //---------------------------------------------------
        /// <summary>方法参数个数</summary>
        internal int ParamsCnt { get; set; }

            if (attr != null)
            {
                ParameterInfo[] parameters = info.GetParameters();
                if (parameters != null)
                    attr.ParamsCnt = parameters.Length;
            }

            
        #region ICloneable Members
        public object Clone()
        {
            HttpApiAttribute obj = new HttpApiAttribute();
            obj.Type = this.Type;
            obj.Description = this.Description;
            obj.CacheDuration = this.CacheDuration;
            obj.Description = this.Description;
            return obj;
        }
        #endregion

                /// <summary>字符串格式化时用的格式</summary>
        public string Format { get; set; }


                    //.....以后再优化，如果无数据，该输出什么？
            //.....文本是输出null还是什么都不输出？图像呢？
            //.....可考虑在webconfig中进行全局设置
            if (obj == null)
                WriteText("null"); 


                        [System.ComponentModel.DefaultValue(ResponseType.Auto)]

                            代码方式：routes.MapHttpRoute(
         name: "DefaultApi",
         routeTemplate: "api/{controller}/{id}",
         defaults: new { id = RouteParameter.Optional }
         );






--------------------------------------------------------
/修改WebCall，增加授权逻辑（2014-05-12）
    - 集成DataResult类
    - 将js文件丢到Js目录下
    - 拆分Tools类
    - 令其支持以下特性(attribute)：
        - AllowAnonymous：是否允许匿名访问（默认为true）
        - AllowUsers ：允许访问的用户
        - AllowRoles ：允许访问的角色
    - 若无授权访问会返回401错误或DataResult对象 （可在Web.confit中配置WebCall-ErrorResponse=HttpError/DataResult）
    - 使用方法
        - 确保ASP.NET 页面实现 HttpContext.Current.User 接口（用于获取当前用户的信息）
        - 请打开所有WebCall的访问权限，无需登录
        - 在需要认证的方法上加上以上标签
    - 详细内容可参考 TestAuth.aspx 示例页面
/修改缓存逻辑，根据有效输入参数来缓存，无效参数不予理会(2013-04-26)
/null值处理
/json数据转换为类实体
    void Update(Person person)
    json {Name:xxx, First:xxx, Last:xxx, Sex:'male'}
    请参考asp.net WebApi
    http://aspnetwebstack.codeplex.com/
    return JsonConvert.DeserializeObject<T>(json, _jsonSettings); 
    JsonSerializerSettings _jsonSettings = new JsonSerializerSettings(); 
    _jsonSettings.MissingMemberHandling = Newtonsoft.Json.MissingMemberHandling.Ignore; 
    _jsonSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore; 
    _jsonSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore; 
    IsoDateTimeConverter datetimeConverter = new IsoDateTimeConverter(); 
    datetimeConverter.DateTimeFormat = "yyyy-MM-dd HH:mm:ss"; 
    _jsonSettings.Converters.Add(datetimeConverter); 
/若实现了IDisposal接口，自动调用释放资源
/增加访问权限控制
    [AccessUsers="xxx,xxx", AccessRoles="xxx,xxx"]
/数据返回类型可用Accepted来控制，而非_type
/客户端可指定js类名
/尝试根据方法的输出类别来推断输出格式
/增加图像输出（png、gif、base64）
/输出服务地址
/废除extjs和jquery两种版本的输出，没啥意义，保留原始js就好了
/恢复WebCallHttpHandler
/恢复WebCallHttpPage（客户端屏蔽了contentType:json,不建议使用）
/支持输出extjs脚本
/支持输出普通js脚本
/WebMethod->WebCall
/考虑废除 WebMethodHandler 和 WebMethodModule
    (1)写class，并用 [WebMethod] 标注
    (2)注册axd:
    (3)ashx调用：
        注册：<script src="CallType_xxx.xxx.axd/js"></script>
        调用：WebMethod_xxx.xxx.axd/HelloWorld?info=me
    (4)aspx调用：
        注册：<script src="CallPage_xxx.xxx.axd/js"></script>
        调用：WebMethod_xxx.xxx.axd/HelloWorld?info=me


    // 获取ajax对象
    GetAjaxObject : function(){
        if (window.ActiveXObject) {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } else if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }
    },
            if (decoder == null) decoder = new SimpleUrlDecoder(context);
        <li><a href="WebCall.App.DemoClass.axd/jq">查看App_Code类映射到客户端的js文件（依赖jquery)</a></li>
        <li><a href="WebCall.App.DemoClass.axd/ext">查看App_Code类映射到客户端的js文件（依赖ExtJs)</a></li>
        <li><a href="CallClass.aspx">调用App_Code类方法（依赖jquery）</a></li>
        <li><a href="CallExt.aspx">调用App_Code类方法（依赖ExtJs）</a></li>

        static ResponseDataType ParseDataType(object o)
        {
            if (o is string)                return ResponseDataType.Text;
            if (o is StringBuilder)         return ResponseDataType.Text;
            if (o is DateTime)              return ResponseDataType.Text;
            if (o is System.Data.DataTable) return ResponseDataType.JSON;
            if (o is System.Drawing.Image)  return ResponseDataType.Image;

            return ResponseDataType.JSON;
        }


        private void Call(string typeName, HttpContext context)
        {
            // 先尝试从缓存中获取处理器
            string cacheName = "WebCall-" + typeName;
            object o = Cache[cacheName];
            if (o != null)
            {
                Kingsoc.Web.WebCall.WebCallHelper.ProcessRequest(context, o);
                return;
            }

            // 找不到着遍历程序集去找这个类
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly assembly in assemblies)
            {
                // 过滤掉系统自带的程序集
                string name = assembly.FullName;
                if (name.StartsWith("System") || name.StartsWith("Microsoft") || name.StartsWith("mscorlib"))
                    continue;

                // 尝试创建对象，且处理Web方法调用请求
                object handler = assembly.CreateInstance(typeName, true);
                if (handler != null)
                {
                    Kingsoc.Web.WebCall.WebCallHelper.ProcessRequest(context, handler);
                    Cache.Add(cacheName, handler, null,
                        Cache.NoAbsoluteExpiration, new TimeSpan(0, _cacheMinutes, 0),
                        CacheItemPriority.Default,
                        null);
                    break;
                }
            }
        }

                    string errorResponse = System.Configuration.ConfigurationManager.AppSettings["HttpApi-ErrorResponse"];
            if (string.IsNullOrEmpty(errorResponse))
                errorResponse = "DataResult";
            if (errorResponse == "HttpError")
            {
                context.Response.Write(info);
                context.Response.StatusCode = errorCode;
                context.Response.StatusDescription = info;
                context.Response.End();
            }
            else
            {
                DataResult dr = new DataResult("false", info, errorCode, null);
                WriteResult(context, dr, ResponseType.JSON);
            }

                
    
  <appSettings>
    <add key="HttpApi-ErrorResponse" value="DataResult"/>   <!-- HttpApi错误时返回的对象： HttpError 或 DataResult -->
  </appSettings>
                  object result = "Api " + methodName + "() fail. Please check parameters. " + ex.Message;

                  
            // 缓存中没有, 则遍历程序集去找这个类
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly assembly in assemblies)
            {
                // 过滤掉系统自带的程序集
                string name = assembly.FullName;
                if (name.StartsWith("System") || name.StartsWith("Microsoft") || name.StartsWith("mscorlib"))
                    continue;

                // 尝试创建对象，且处理Web方法调用请求
                handler = assembly.CreateInstance(typeName, true);
                if (handler != null)
                {
                    HttpApiHelper.ProcessRequest(context, handler);
                    DisposeIfNeed(handler);
                    SaveHandlerInCache(typeName, assembly, handler);
                    break;
                }
            }

                [XmlInclude(typeof(ErrorResponse))]


        public DataResult(bool result, String info = "", object data = null, object extra = null)
        {
            Result = result.ToString();
            Info = info;
            Data = data;
            Extra = extra;
        }

                /// <summary>
        /// 构造接口清单页面
        /// </summary>
        static StringBuilder GetApiHtml(API api)
        {
            // 概述信息
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("<h1>" + api.Name + "</h1>");
            sb.AppendLine("<h3>" + api.Description + "</h3>");

            // 属性
            sb.AppendLine("<h2>属性</h2>");
            sb.AppendLine("<br/><table border=1 style='border-collapse: collapse' width='100%' cellpadding='2' cellspacing='0'>");
            sb.AppendFormat("<tr><td width='100'>名称    </td><td>值</td></tr>");
            sb.AppendFormat("<tr><td width='100'>返回类型</td><td>{0}&nbsp;</td></tr>", api.ReturnType);
            sb.AppendFormat("<tr><td width='100'>缓存(秒)</td><td>{0}&nbsp;</td></tr>", api.CacheDuration);
            sb.AppendFormat("<tr><td width='100'>限登陆  </td><td>{0}&nbsp;</td></tr>", api.AuthLogin);
            sb.AppendFormat("<tr><td width='100'>限用户  </td><td>{0}&nbsp;</td></tr>", api.AuthUsers);
            sb.AppendFormat("<tr><td width='100'>限角色  </td><td>{0}&nbsp;</td></tr>", api.AuthRoles);
            sb.AppendFormat("<tr><td width='100'>访问方式</td><td>{0}&nbsp;</td></tr>", api.Verbs);
            sb.AppendFormat("<tr><td width='100'>状态    </td><td>{0}&nbsp;</td></tr>", api.Status);
            sb.AppendFormat("<tr><td width='100'>备注    </td><td>{0}&nbsp;</td></tr>", api.Remark);
            sb.AppendFormat("<tr><td width='100'>测试URL </td><td>{0}&nbsp;</td></tr>", api.UrlTest);
            sb.AppendLine("</tr></table>");

            // 参数
            sb.AppendLine("<h2>参数</h2>");
            sb.AppendLine("<br/><table border=1 style='border-collapse: collapse' width='100%' cellpadding='2' cellspacing='0'>");
            sb.AppendFormat("<tr><td width='100'>参数名</td><td>描述</td><td>类型</td><td>说明</td><td>缺省值</td></tr>");
            foreach (var p in api.Params)
            {
                sb.AppendFormat("<tr><td>{0}&nbsp;</td><td>{1}&nbsp;</td><td>{2}&nbsp;</td><td>{3}&nbsp;</td><td>{4}&nbsp;</td></tr>"
                    ,p.Name
                    ,p.Description
                    ,p.Type
                    ,p.Info
                    ,p.DefaultValue
                    );
            }
            sb.AppendLine("</tr></table>");
            return sb;
        }


                // 检测客户端IP是否在授权列表内
        bool CheckIP()
        {
            string[] ips = HttpApiConfig.Instance.AuthIPs?.Split(new char[] {','}, StringSplitOptions.RemoveEmptyEntries);
            if (ips == null || ips.Length == 0)
                return true;
            else
            {
                string ip = Asp.GetClientIP();
                return (ips.Contains(ip));
            }
        }

        
        [ConfigurationProperty("authIPs")]
        public string AuthIPs
        {
            get { return (string)this["authIPs"]; }
            set { this["authIPs"] = value; }
        }

            public event AuthHandler OnAuth;
    public delegate bool AuthHandler(IPrincipal pricipal);
        sb.AppendFormat("<{0}>", field.Name);

                // 一直递归到基础数据类别（各种类型；避免无限递归互相引用；递归层次限制）
                var o = field.GetValue(obj);
                var t = field.DeclaringType;
                var cfg = HttpApiConfig.Instance;
                if (o == null)
                    sb.Append("");
                else if (o is string)
                    sb.Append(GetObjText(o));
                else if (o is DateTime)
                    sb.Append(GetDateText(o, cfg.FormatDateTime));
                else if (t.IsEnum)
                    sb.Append(GetEnumText(o, cfg.FormatEnum));
                else if (t.IsValueType)
                    sb.Append(GetObjText(o));
                else if (o is IEnumerable)
                    VisitCollection(sb, o as IEnumerable);
                else
                {
                    var subFields = field.PropertyType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
                    if (subFields.Count() > 0)
                        VisitFields(sb, o, subFields);
                    else
                        sb.Append(GetObjText(o));
                }

                sb.AppendFormat("</{0}>", field.Name);



                        /// <summary>
        /// 构造API参数页面
        /// </summary>
        static string BuildApiParamsHtml(API api)
        {
            var sb = new StringBuilder();
            sb.AppendLine(BuildCss());
            sb.AppendFormat("<br/><table class='table table-sm'>");
            sb.AppendFormat("<thead><tr><td width='100'>参数名</td><td>描述</td><td>类型</td><td>说明</td><td>缺省值</td></tr></thead>");
            foreach (var p in api.Params)
            {
                sb.AppendFormat("<tr><td>{0}&nbsp;</td><td>{1}&nbsp;</td><td>{2}&nbsp;</td><td>{3}&nbsp;</td><td>{4}&nbsp;</td></tr>"
                    , p.Name
                    , p.Description
                    , p.Type
                    , p.Info
                    , p.DefaultValue
                    );
            }
            sb.AppendFormat("</tr></table>");
            return sb.ToString();
        }
 style='width:200px; border:none'


                 <td width='70'>返回类型</td>
                <td width='70'>缓存(秒)</td>
                <td width='70'>校验IP</td>
                <td width='80'>校验Token</td>
                <td width='70'>校验登录</td>
                <td width='70'>校验用户</td>
                <td width='70'>校验角色</td>
                <td width='70'>校验动作</td>
                <td width='70'>访问日志</td>
                <td width='70'>状态</td>
                <td>备注</td>

                            sb.AppendLine(@"<thead><tr>
                <td width='200'>接口名</td>
                <td width='200'>说明</td>
                <td width='70'>返回类型</td>
                <td width='70'>缓存(秒)</td>
                <td width='70'>校验IP</td>
                <td width='80'>校验Token</td>
                <td width='70'>校验登录</td>
                <td width='70'>校验用户</td>
                <td width='70'>校验角色</td>
                <td width='70'>校验动作</td>
                <td width='70'>访问日志</td>
                <td width='70'>状态</td>
                <td>备注</td>
                </tr></thead>");

                            /*
            return @"
                <style>
                table {border-collapse: collapse}
                tr:first-child {background: #f2f2f2;}
                input[type=""text""] {background-color: #f2f2f2;}
                input[type=""submit""] {
                    width: 120px;
                    height: 28px;
                    background-color: #68c9e8;
                    border-radius: 5px;
                    color: white;
                    border: none;
                    font-size: 14;
                }
                input[type=""submit""]:hover {
                    cursor: hand
                }
                </style>
            ";
            */

                    // 请求页面
        private void Application_BeginRequest(object sender, EventArgs e)
        {
            var u = HttpContext.Current.Request.Url.AbsolutePath;
            var url = u.ToString().ToLower();

            // 以 Page.aspx/Method 或 Handler.ashx/Method 方式调用
            if (!url.Contains("httpapi/"))
            {
                int m = url.LastIndexOf(".");
                int n = url.LastIndexOf("/");
                if (m != -1 && n != -1 && m < n)
                {
                    url = url.Substring(0, n);
                    var ext = url.Substring(m);
                    var exts = new List<string>() { ".aspx", "ashx" };
                    if (exts.Contains(ext))
                        HttpApiHandler.HandlerHttpApiRequest(HttpContext.Current);
                }
            }
        }

        private void Application_EndRequest(object sender, EventArgs e)
        {
            throw new NotImplementedException();
        }

                    application.BeginRequest += Application_BeginRequest;
            application.EndRequest += Application_EndRequest;


            
                int m = url.LastIndexOf(".");
                if (m != -1 && n != -1 && m < n)
                {
                    var ext = url.Substring(m);

                    if (ext == ".aspx")
                    {
                        var factory = (PageHandlerFactory)Activator.CreateInstance(typeof(PageHandlerFactory), true);
                        handler = factory.GetHandler(HttpContext.Current, req.HttpMethod, url, url);
                    }
                    else if (ext == ".ashx")
                    {
                        //var factory = Activator.CreateInstance("System.Web.dll", "System.Web.UI.SimpleHandlerFactory", new object[] { }) as IHttpHandlerFactory;  // 无法创建
                        //handler = factory.GetHandler(HttpContext.Current, req.HttpMethod, url, url);
                        type = WebHandlerParser.GetCompiledType(url, url, context);
                        handler = Activator.CreateInstance(type) as IHttpHandler;
                    }
                }





                                sb.AppendFormat("//-----------------------------------------------------------------\r\n");
                sb.AppendFormat("// {0} : {1}\r\n", Resources.Url, api.Url);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.CacheSeconds,  api.CacheDuration);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.ReturnType,  api.ReturnType);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.Description, api.Description);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthVerbs, api.AuthVerbs);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthIP,  api.AuthIP);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthToken,  api.AuthToken);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthLogin,  api.AuthLogin);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthUser,  api.AuthUsers);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.AuthRole,  api.AuthRoles);
                sb.AppendFormat("// {0} : {1}\r\n", Resources.Remark, api.Remark);
                sb.AppendFormat("//-----------------------------------------------------------------\r\n");

                            sb.AppendFormat("<td>{0}</td>", Resources.Expire);
                sb.AppendFormat("<td>{0:yyyy-MM-dd}&nbsp;</td>", api.Expire);
            sb.AppendFormat("<td>{0}</td>", Resources.Remark);
            sb.AppendFormat("<td>{0}&nbsp;</td>", api.Remark);

                            var cfg = HttpApiConfig.Instance;
                var settings = new JsonSerializerSettings();
                settings.MissingMemberHandling = MissingMemberHandling.Ignore;
                settings.NullValueHandling = NullValueHandling.Ignore;
                settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;

                // 小驼峰命名法
                if (cfg.FormatLowCamel)
                    settings.ContractResolver = new CamelCasePropertyNamesContractResolver();

                // 递进格式
                settings.Formatting = cfg.FormatIndented;

                // 时间格式
                var datetimeConverter = new IsoDateTimeConverter();
                datetimeConverter.DateTimeFormat = cfg.FormatDateTime;
                settings.Converters.Add(datetimeConverter);

                // 枚举格式
                if (cfg.FormatEnum == EnumFomatting.Text)
                    settings.Converters.Add(new StringEnumConverter());

                // 长数字格式化（转化为字符串）
                var types = cfg.FormatLongNumber.ParseEnums<TypeCode>();
                settings.Converters.Add(new LongNumberToStringConverter(types));

                //

   /// <summary>
    /// 页面请求处理器解析器。可获取页面请求对应的处理类。
    /// （抄的 Asp.net 源码）
    /// </summary>
    internal class WebHandlerParser : SimpleWebHandlerParser
    {
        private WebHandlerParser(HttpContext context, string virtualPath, string physicalPath)
            : base(context, virtualPath, physicalPath)
        {
        }
        internal static Type GetCompiledType(string virtualPath, string physicalPath, HttpContext context)
        {
            var parser = new WebHandlerParser(context, virtualPath, physicalPath);
            return parser.GetCompiledTypeFromCache();
        }
        protected override string DefaultDirectiveName
        {
            get { return "webhandler"; }
        }
    }


    /// <summary>
    /// 浏览器验证
    /// </summary>
    public class ValidateBrowserMiddleware
    {
        private readonly RequestDelegate _next;
        public ValidateBrowserMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task Invoke(HttpContext httpContext)
        {
            if (httpContext.Request.Headers["User-Agent"].Any(h => h.ToLower().Contains("trident")))
                httpContext.Response.StatusCode = 403;
            else
                await _next.Invoke(httpContext);
        }
    }




    
        //----------------------------------------------------------------------
        // ASP.NET 2.0 用WebResource.axd封装，可提供资源的url地址
        //----------------------------------------------------------------------
        /// <summary>获取资源url</summary>
        /// <param name="resourceName"></param>
        /// <returns>
        /// 类似：WebResource.axd?a=pWebCtrl&amp;r=WebCtrl.cutecat.jpg&amp;t=632390947985312500
        /// a  - assembly
        /// r  - resourceName
        /// t  - assembly's timeStamp
        /// </returns>
        public string GetResourceUrl(string resourceName)
        {
            return (Asp.Current.Handler as Page).ClientScript.GetWebResourceUrl(this.GetType(), resourceName);
        }

        /// <summary>将资源注册为css</summary>
        /// <param name="resourceName"></param>
        public void RegistCss(string resourceName)
        {
            Page page = Asp.Current.Handler as Page;
            if (page != null)
            {
                string url = page.ClientScript.GetWebResourceUrl(this.GetType(), resourceName);
                string text = string.Format("<link rel='stylesheet' text='text/css' href='{0}' />", url);
                LiteralControl lc = new LiteralControl(text);
                page.Header.Controls.Add(lc);
            }
        }

        /// <summary>将资源注册为script</summary>
        /// <param name="resourceName"></param>
        public void RegistScript(string resourceName)
        {
            Page page = Asp.Current.Handler as Page;
            if (page != null)
            {
                string url = page.ClientScript.GetWebResourceUrl(this.GetType(), resourceName);
                page.ClientScript.RegisterClientScriptInclude(resourceName, url);
            }
        }

                    /*
            ASP.NET Core附带以下中间件组件：
            Authentication	            提供身份验证支持
            CORS	                    配置跨域资源共享
            Response Caching	        提供缓存响应支持
            Response Compression	    提供响应压缩支持
            Routing	                    定义和约束请求路由
            Session	                    提供用户会话管理
            Static Files	            为静态文件和目录浏览提供服务提供支持
            URL Rewriting Middleware	用于重写 Url，并将请求重定向的支持
            */


                    private static void SignInHandler(IApplicationBuilder app)
        {
            app.Run(async context =>
            {
                AuthMiddleware.SignIn(context, 1, "kevin", "kevin@some.com", "12345678");
                await context.Response.WriteAsync("SingIn ok");
            });
        }
        private static void SignOutHandler(IApplicationBuilder app)
        {
            app.Run(async context =>
            {
                AuthMiddleware.SignOut(context);
                await context.Response.WriteAsync("SignOut ok");
            });
        }

        
    /// <summary>
    /// AspCore 扩展方法
    /// </summary>
    public static class AspCore
    {
        public static string GetUrl(this HttpRequest request)
        {
            return new StringBuilder()
                .Append(request.Scheme)
                .Append("://")
                .Append(request.Host)
                .Append(request.PathBase)
                .Append(request.Path)
                .Append(request.QueryString)
                .ToString();
        }
    }



    
        /// <summary></summary>
        /// <param name="host"></param>
        /// <param name="url"></param>
        /// <returns></returns>
        public static string MapPath(IHostingEnvironment host, string url)
        {
            return Path.Combine(host.ContentRootPath, .Replace(@"/", @"\"));
        }
